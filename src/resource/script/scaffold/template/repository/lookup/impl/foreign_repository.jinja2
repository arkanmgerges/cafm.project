"""
The file is generated by scaffold script
@author: Arkan M. Gerges<arkan.m.gerges@gmail.com>
"""
{%set className= model.name | upperCamelCase%}
{%set domainModelClassName= model.domain_model.name | upperCamelCase%}
{%-set lowerCamelModelName= model.name | lowerCamelCase-%}
{%-set funcParams= model.field | mapFuncParams-%}
{%-set funcParamsWithDefaultNone= model.field | mapFuncParams(True)-%}
{%-set funcArgs= model.field | mapFuncArgs-%}
{%-set funcArgsByDict= model.field | mapFuncArgs('objListParamsItem', 'dictionary', '=', True)-%}
{%-set funcArgsLowerCase= model.field | mapFuncArgsLowerCase-%}
{%-set funcArgsLowerCaseWithSourceObject= model.field | mapFuncArgsLowerCase(None, None, '=', '_sourceObject')-%}
{%-set classNameWords= model.name | spacedWords%}
{%-set domainModelClassNameWords= model.domain_model.name | spacedWords%}
{%-set filePath= model.path | replace('/', '.')%}
{%-set domainModelFilePath= model.domain_model.path | replace('/', '.')%}
{%-set esIndexModelClassName= model.es_index_model.domain_model.name | upperCamelCase%}
{%-set vars=['i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't']%}

{%- macro loopPaths(loopIndex) -%}
    {%- set loop0 = loopIndex + 1 -%}     
    {%- for path2 in model.repo_data.paths[:loop0] -%}
        {%- if not loop.last -%}
    {{ path2 }}[{{ vars[loop.index0] }}].
        {%- else -%}
    {{ path2 }}
        {%- endif -%}
    {%- endfor -%}
{%- endmacro -%}

import os

from elasticsearch_dsl import UpdateByQuery, Q, Search
from elasticsearch_dsl.connections import connections
from sqlalchemy import create_engine

from src.application.{{ filePath }}.{{ className }}Repository import {{ className }}Repository
from src.domain_model.{{ model.domain_model.path | replace('/', '.') }}.{{ domainModelClassName }} import {{ domainModelClassName }}
from src.port_adapter.repository.es_model.{{ model.path | replace('/', '.') }}.{{ esIndexModelClassName }} import ({{ esIndexModelClassName }} as Es{{ esIndexModelClassName }},)
from src.resource.logging.decorator import debugLogger
from src.resource.logging.logger import logger


class {{ className }}RepositoryImpl({{ className }}Repository):
    def __init__(self):
        try:
            self._db = create_engine(
                f"mysql+mysqlconnector://{os.getenv('CAFM_PROJECT_DB_USER', 'root')}:{os.getenv('CAFM_PROJECT_DB_PASSWORD', '1234')}@{os.getenv('CAFM_PROJECT_DB_HOST', '127.0.0.1')}:{os.getenv('CAFM_PROJECT_DB_PORT', '3306')}/{os.getenv('CAFM_PROJECT_DB_NAME', 'cafm-project')}"
            )
            self._es = connections.create_connection(
                hosts=[
                    f'{os.getenv("CAFM_PROJECT_ELASTICSEARCH_HOST", "elasticsearch")}:{os.getenv("CAFM_PROJECT_ELASTICSEARCH_PORT", 9200)}'
                ]
            )
        except Exception as e:
            logger.warn(
                f"[{{"{"}}{{ className }}RepositoryImpl.__init__.__qualname__}] Could not connect to the db, message: {e}"
            )
            raise Exception(f"Could not connect to the db, message: {e}")


    {% if 'repo_data' in model and 'paths' in model.repo_data %}
        {%-set fullPath = model.repo_data.paths|join(".") %}    
    @debugLogger
    def delete(self, obj: {{ domainModelClassName }}):
        if obj is not None:
            UpdateByQuery(index=Es{{ esIndexModelClassName }}.alias()).using(self._es) \
                .filter('nested', path="{{ fullPath }}",
                        query=Q("term",
                                **{"{{ fullPath }}.id": obj.id()})) \
                .script(
                source="""
                    {%- for currentPath in model.repo_data.paths %}                        
                        if (ctx._source.{{ loopPaths(loop.index0) }} instanceof List) {
                        {%set currentVar = vars[loop.index0] %}
                            for (int {{ currentVar }}=ctx._source.{{ loopPaths(loop.index0) }}.length - 1; {{ currentVar }} >= 0; {{ currentVar }}--) {
                        {%- if loop.last %}
                                if (ctx._source.{{ loopPaths(loop.index0 )}}[{{ vars[loop.index0] }}].id == params.id) {
                                    ctx._source.{{ loopPaths(loop.index0) }}.remove({{vars[loop.index0] }});
                                }
                        {%- endif %}
                    {%- endfor %}
                                        }
                        {%- for currentPath in model.repo_data.paths %}                        
                        }
                        {%- endfor %}
                    }
                            """,
                params={"id": obj.id()}).execute()
    {%- else %}
    @debugLogger
    def delete(self, obj: {{ domainModelClassName }}):
        if obj is not None:
            Search(index=Es{{ esIndexModelClassName }}.alias()).using(self._es).filter('nested', path="{{ model.domain_model.name }}", query=Q("term", **{"{{ model.domain_model.name }}.id": obj.id()})).delete()
    {%- endif %}

    {%- macro generateImportsForSaveMethod(model) %}
        {%- if 'foreign' in model and model.foreign == true and 'repo_data' not in model %}        
        from src.domain_model.{{model.domain_model.path | replace("/", ".")}} import {{model.name | upperCamelCase}}Repository
        {{model.name | lowerCamelCase}}Repo = AppDi.instance.get({{model.name | upperCamelCase}}Repository)
        {%- endif %}
        {%- for field in model.field %}
        {%- if field.type == 'foreign' %}
        {{ generateImportsForSaveMethod(field.link) }}
        {%- endif %}
        {%- endfor %}
    {%- endmacro %}

    {%- macro generateDomainModelObjectsForSaveMethod(model) %}
        {%- if 'foreign' in model and model.foreign == true and 'repo_data' not in model %}        
        {{model.name|lowerCamelCase}} = {{model.name | lowerCamelCase}}Repo.{{model.name}}ById(obj.unitId())
        {%- endif %}
        {%- for field in model.field %}
        {%- if field.type == 'foreign' and 'repo_data' not in field.link%}
        {{ generateDomainModelObjectsForSaveMethod(field.link) }}
        {%- endif %}
        {%- endfor %}
    {%- endmacro %}

    {%- macro generateDictObjectsForSaveMethod(model) -%}
        {
        {%- for field in model.field -%}
        {%- if field.type == 'foreign' and 'repo_data' not in field.link%}
        {{ generateDictObjectsForSaveMethod(field.link) }}
        {%-else -%}
        "{{field.name}}": {{model.name | lowerCamelCase}}.{{field.name|lowerCamelCase}}(),
        {%- endif %}
        {%- endfor -%}
        }
    {%- endmacro -%}

    @debugLogger
    def save(self, obj: {{ domainModelClassName }}):
    {% if 'repo_data' in model and 'paths' in model.repo_data %}
        import src.port_adapter.AppDi as AppDi
        {%- for field in model.field %}
        {%- if field.type == 'foreign' and 'repo_data' not in field.link %}
        {{ generateImportsForSaveMethod(field.link) }}
        {%- endif %}
        {%- endfor %}

        {%- for field in model.field %}
        {%- if field.type == 'foreign' and 'repo_data' not in field.link %}
        {{ generateDomainModelObjectsForSaveMethod(field.link) }}
        {%- endif %}
        {%- endfor %}

        {%- for field in model.field %}
        {%- if field.type == 'foreign' and 'repo_data' not in field.link %}
        {{field.name | lowerCamelCase}}Dict = {{ generateDictObjectsForSaveMethod(field.link) }}
        {%- endif %}
        {%- endfor %}

        {%-set fullPath = model.repo_data.paths[:(model.repo_data.paths| length) - 1]|join(".") %}
        {%-set parentPath = model.repo_data.paths[(model.repo_data.paths| length) - 2 : (model.repo_data.paths| length) - 1]|join(".") %}
        if obj is not None:
                UpdateByQuery(index=Es{{ esIndexModelClassName }}.alias()).using(self._es) \
                .filter('nested', path="{{ fullPath }}",
                        query=Q("term",
                                **{"{{ fullPath }}.id": obj.{{ parentPath | singularize | lowerCamelCase }}Id()})) \
                .script(source="""{%- for field in model.field -%}
                {%- if field.name != "id" %}
                if (params.{{ field.name }} != null) {
                                ctx._source.{{ model.domain_model.name }}.{{ field.name }} = params.{{ field.name }};
                            }
                {% endif %}
                {%- endfor -%}
                """, params={
                    {%- for field in model.field %}
                    {%- if field.name != "id" %}
                    {%- if field.type != 'foreign' %}
                    "{{ field.name }}": obj.{{ field.name | singularize | lowerCamelCase }}(),
                    {%-elif field.type == 'foreign' and 'repo_data' not in field.link %}
                    "{{ field.name }}": {{field.name | lowerCamelCase}}Dict,
                    {%-endif%}
                    {%- endif %}
                    {%- endfor %}
                    }) \
                .execute()
    {%- else %}
        if obj is not None:
            UpdateByQuery(index=Es{{ esIndexModelClassName }}.alias()).using(self._es) \
             .filter('nested', path="{{ model.domain_model.name }}",
                     query=Q("term",
                             **{"{{ model.domain_model.name }}.id": obj.id()})) \
             .script(source="""{%- for field in model.field -%}
             {%- if field.name != "id" %}
             if (params.{{ field.name }} != null) {
                            ctx._source.{{ model.domain_model.name }}.{{ field.name }} = params.{{ field.name }};
                        }
             {% endif %}
             {%- endfor -%}
             """, params={
                 {%- for field in model.field %}
                 {%- if field.name != "id" %}
                 "{{ field.name }}": obj.{{ field.name | singularize | lowerCamelCase }}(),
                 {%- endif %}
                 {%- endfor %}
                 }) \
            .execute()
{%- endif %}